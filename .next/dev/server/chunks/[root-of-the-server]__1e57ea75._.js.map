{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/ethan/Desktop/chiliz-ja/lib/prisma.ts"],"sourcesContent":["/**\n * Prisma Client Singleton\n * Ensures a single instance of PrismaClient is used across the application\n */\n\nimport { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n  })\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n\nexport default prisma\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAED;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEF,wCAA2C,gBAAgB,MAAM,GAAG;uCAErD"}},
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":["file:///Users/ethan/Desktop/chiliz-ja/lib/auth.ts"],"sourcesContent":["/**\n * Authentication Helper Functions\n * Handles wallet-based authentication with JWT sessions\n */\n\nimport { cookies } from 'next/headers'\nimport jwt from 'jsonwebtoken'\nimport { prisma } from './prisma'\nimport { User } from '@prisma/client'\nimport crypto from 'crypto'\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'CHANGE_THIS_SECRET_IN_PRODUCTION'\nconst SESSION_COOKIE_NAME = 'auth_session'\nconst SESSION_DURATION_DAYS = 7\n\n/**\n * Generate a random nonce for wallet authentication\n */\nexport function generateNonce(): string {\n  return crypto.randomBytes(32).toString('hex')\n}\n\n/**\n * Create an authentication message for wallet signing\n */\nexport function createAuthMessage(nonce: string, address: string): string {\n  return `Sign this message to authenticate with your wallet.\n\nAddress: ${address}\nNonce: ${nonce}\n\nThis request will not trigger a blockchain transaction or cost any gas fees.`\n}\n\n/**\n * Create a JWT session token\n */\nexport function createSessionToken(userId: string): string {\n  const expiresIn = `${SESSION_DURATION_DAYS}d`\n  return jwt.sign({ userId }, JWT_SECRET, { expiresIn })\n}\n\n/**\n * Verify a JWT session token\n */\nexport function verifySessionToken(token: string): { userId: string } | null {\n  try {\n    const decoded = jwt.verify(token, JWT_SECRET) as { userId: string }\n    return decoded\n  } catch (error) {\n    return null\n  }\n}\n\n/**\n * Store a session in the database and set cookie\n */\nexport async function createSession(userId: string): Promise<string> {\n  const token = createSessionToken(userId)\n  const expiresAt = new Date()\n  expiresAt.setDate(expiresAt.getDate() + SESSION_DURATION_DAYS)\n\n  await prisma.session.create({\n    data: {\n      userId,\n      token,\n      expiresAt,\n    },\n  })\n\n  // Set HTTP-only cookie\n  const cookieStore = await cookies()\n  cookieStore.set(SESSION_COOKIE_NAME, token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax',\n    maxAge: SESSION_DURATION_DAYS * 24 * 60 * 60,\n    path: '/',\n  })\n\n  return token\n}\n\n/**\n * Get current user from session cookie\n */\nexport async function getCurrentUser(): Promise<User | null> {\n  try {\n    const cookieStore = await cookies()\n    const sessionToken = cookieStore.get(SESSION_COOKIE_NAME)?.value\n\n    if (!sessionToken) {\n      return null\n    }\n\n    // Verify JWT\n    const decoded = verifySessionToken(sessionToken)\n    if (!decoded) {\n      return null\n    }\n\n    // Find session in DB\n    const session = await prisma.session.findUnique({\n      where: { token: sessionToken },\n      include: { user: true },\n    })\n\n    if (!session) {\n      return null\n    }\n\n    // Check if session expired\n    if (session.expiresAt < new Date()) {\n      await prisma.session.delete({ where: { id: session.id } })\n      return null\n    }\n\n    return session.user\n  } catch (error) {\n    console.error('Error getting current user:', error)\n    return null\n  }\n}\n\n/**\n * Destroy current session\n */\nexport async function destroySession(): Promise<void> {\n  try {\n    const cookieStore = await cookies()\n    const sessionToken = cookieStore.get(SESSION_COOKIE_NAME)?.value\n\n    if (sessionToken) {\n      // Delete from database\n      await prisma.session.deleteMany({\n        where: { token: sessionToken },\n      })\n    }\n\n    // Clear cookie\n    cookieStore.delete(SESSION_COOKIE_NAME)\n  } catch (error) {\n    console.error('Error destroying session:', error)\n  }\n}\n\n/**\n * Require authentication - throws if not authenticated\n */\nexport async function requireAuth(): Promise<User> {\n  const user = await getCurrentUser()\n  if (!user) {\n    throw new Error('Unauthorized - Please connect your wallet')\n  }\n  return user\n}\n\n/**\n * Clean up expired sessions (can be called periodically)\n */\nexport async function cleanupExpiredSessions(): Promise<void> {\n  await prisma.session.deleteMany({\n    where: {\n      expiresAt: {\n        lt: new Date(),\n      },\n    },\n  })\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;;;;;AAED;AACA;AACA;AAEA;;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAC7C,MAAM,sBAAsB;AAC5B,MAAM,wBAAwB;AAKvB,SAAS;IACd,OAAO,gHAAM,CAAC,WAAW,CAAC,IAAI,QAAQ,CAAC;AACzC;AAKO,SAAS,kBAAkB,KAAa,EAAE,OAAe;IAC9D,OAAO,CAAC;;SAED,EAAE,QAAQ;OACZ,EAAE,MAAM;;4EAE6D,CAAC;AAC7E;AAKO,SAAS,mBAAmB,MAAc;IAC/C,MAAM,YAAY,GAAG,sBAAsB,CAAC,CAAC;IAC7C,OAAO,2MAAG,CAAC,IAAI,CAAC;QAAE;IAAO,GAAG,YAAY;QAAE;IAAU;AACtD;AAKO,SAAS,mBAAmB,KAAa;IAC9C,IAAI;QACF,MAAM,UAAU,2MAAG,CAAC,MAAM,CAAC,OAAO;QAClC,OAAO;IACT,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF;AAKO,eAAe,cAAc,MAAc;IAChD,MAAM,QAAQ,mBAAmB;IACjC,MAAM,YAAY,IAAI;IACtB,UAAU,OAAO,CAAC,UAAU,OAAO,KAAK;IAExC,MAAM,yHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;QAC1B,MAAM;YACJ;YACA;YACA;QACF;IACF;IAEA,uBAAuB;IACvB,MAAM,cAAc,MAAM,IAAA,2QAAO;IACjC,YAAY,GAAG,CAAC,qBAAqB,OAAO;QAC1C,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,QAAQ,wBAAwB,KAAK,KAAK;QAC1C,MAAM;IACR;IAEA,OAAO;AACT;AAKO,eAAe;IACpB,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,2QAAO;QACjC,MAAM,eAAe,YAAY,GAAG,CAAC,sBAAsB;QAE3D,IAAI,CAAC,cAAc;YACjB,OAAO;QACT;QAEA,aAAa;QACb,MAAM,UAAU,mBAAmB;QACnC,IAAI,CAAC,SAAS;YACZ,OAAO;QACT;QAEA,qBAAqB;QACrB,MAAM,UAAU,MAAM,yHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9C,OAAO;gBAAE,OAAO;YAAa;YAC7B,SAAS;gBAAE,MAAM;YAAK;QACxB;QAEA,IAAI,CAAC,SAAS;YACZ,OAAO;QACT;QAEA,2BAA2B;QAC3B,IAAI,QAAQ,SAAS,GAAG,IAAI,QAAQ;YAClC,MAAM,yHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;gBAAE,OAAO;oBAAE,IAAI,QAAQ,EAAE;gBAAC;YAAE;YACxD,OAAO;QACT;QAEA,OAAO,QAAQ,IAAI;IACrB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;IACT;AACF;AAKO,eAAe;IACpB,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,2QAAO;QACjC,MAAM,eAAe,YAAY,GAAG,CAAC,sBAAsB;QAE3D,IAAI,cAAc;YAChB,uBAAuB;YACvB,MAAM,yHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;gBAC9B,OAAO;oBAAE,OAAO;gBAAa;YAC/B;QACF;QAEA,eAAe;QACf,YAAY,MAAM,CAAC;IACrB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;IAC7C;AACF;AAKO,eAAe;IACpB,MAAM,OAAO,MAAM;IACnB,IAAI,CAAC,MAAM;QACT,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAKO,eAAe;IACpB,MAAM,yHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;QAC9B,OAAO;YACL,WAAW;gBACT,IAAI,IAAI;YACV;QACF;IACF;AACF"}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":["file:///Users/ethan/Desktop/chiliz-ja/lib/ethers.ts"],"sourcesContent":["/**\n * Ethereum / Blockchain Helper Functions\n * Provides ethers.js utilities for interacting with smart contracts\n */\n\nimport { ethers, Contract, JsonRpcProvider } from 'ethers'\n\n// Initialize provider for reading blockchain data\nlet provider: JsonRpcProvider | null = null\n\nexport function getProvider(): JsonRpcProvider {\n  if (!provider) {\n    const rpcUrl = process.env.CHAIN_RPC_URL\n    if (!rpcUrl) {\n      throw new Error('CHAIN_RPC_URL environment variable is not set')\n    }\n    provider = new ethers.JsonRpcProvider(rpcUrl)\n  }\n  return provider\n}\n\n// ERC20 Token ABI (minimal interface for CHZ token)\nconst ERC20_ABI = [\n  'function balanceOf(address owner) view returns (uint256)',\n  'function transfer(address to, uint256 amount) returns (bool)',\n  'function allowance(address owner, address spender) view returns (uint256)',\n  'function approve(address spender, uint256 amount) returns (bool)',\n  'function transferFrom(address from, address to, uint256 amount) returns (bool)',\n]\n\n// Payment Contract ABI\nconst PAYMENT_CONTRACT_ABI = [\n  'event PaymentDone(address indexed payer, uint256 amount)',\n  'function pay() external',\n  'function fixedAmount() view returns (uint256)',\n  'function wallet1() view returns (address)',\n  'function wallet2() view returns (address)',\n]\n\n// Staking Contract ABI (minimal interface)\nconst STAKING_CONTRACT_ABI = [\n  'function stakedBalanceOf(address user) external view returns (uint256)',\n]\n\n/**\n * Get CHZ Token Contract instance\n */\nexport function getChzTokenContract(): Contract {\n  const tokenAddress = process.env.CHZ_TOKEN_ADDRESS\n  if (!tokenAddress) {\n    throw new Error('CHZ_TOKEN_ADDRESS environment variable is not set')\n  }\n  return new ethers.Contract(tokenAddress, ERC20_ABI, getProvider())\n}\n\n/**\n * Get Payment Contract instance\n */\nexport function getPaymentContract(): Contract {\n  const contractAddress = process.env.PAYMENT_CONTRACT_ADDRESS\n  if (!contractAddress) {\n    throw new Error('PAYMENT_CONTRACT_ADDRESS environment variable is not set')\n  }\n  return new ethers.Contract(contractAddress, PAYMENT_CONTRACT_ABI, getProvider())\n}\n\n/**\n * Get Staking Contract instance\n */\nexport function getStakingContract(): Contract {\n  const contractAddress = process.env.STAKING_CONTRACT_ADDRESS\n  if (!contractAddress) {\n    throw new Error('STAKING_CONTRACT_ADDRESS environment variable is not set')\n  }\n  return new ethers.Contract(contractAddress, STAKING_CONTRACT_ABI, getProvider())\n}\n\n/**\n * Get staked amount for a given user address\n * @param userAddress - Ethereum wallet address\n * @returns Staked amount in CHZ (smallest unit)\n */\nexport async function getStakedAmount(userAddress: string): Promise<bigint> {\n  try {\n    const stakingContract = getStakingContract()\n    const stakedBalance = await stakingContract.stakedBalanceOf(userAddress)\n    return BigInt(stakedBalance.toString())\n  } catch (error) {\n    console.error('Error fetching staked amount:', error)\n    throw new Error('Failed to fetch staked amount from blockchain')\n  }\n}\n\n/**\n * Verify a transaction and check if it's a valid payment\n * @param txHash - Transaction hash\n * @returns Transaction receipt if valid, null otherwise\n */\nexport async function verifyPaymentTransaction(txHash: string) {\n  try {\n    const provider = getProvider()\n    const receipt = await provider.getTransactionReceipt(txHash)\n\n    if (!receipt) {\n      return { valid: false, error: 'Transaction not found' }\n    }\n\n    // Check if transaction succeeded\n    if (receipt.status !== 1) {\n      return { valid: false, error: 'Transaction failed' }\n    }\n\n    // Verify the transaction was sent to the payment contract\n    const paymentContractAddress = process.env.PAYMENT_CONTRACT_ADDRESS?.toLowerCase()\n    if (receipt.to?.toLowerCase() !== paymentContractAddress) {\n      return { valid: false, error: 'Transaction not sent to payment contract' }\n    }\n\n    // Try to decode the PaymentDone event\n    const paymentContract = getPaymentContract()\n    let paymentAmount = '0'\n    let payerAddress = ''\n\n    for (const log of receipt.logs) {\n      try {\n        const parsedLog = paymentContract.interface.parseLog({\n          topics: [...log.topics],\n          data: log.data,\n        })\n\n        if (parsedLog?.name === 'PaymentDone') {\n          payerAddress = parsedLog.args.payer\n          paymentAmount = parsedLog.args.amount.toString()\n          break\n        }\n      } catch (e) {\n        // Skip logs that don't match\n        continue\n      }\n    }\n\n    return {\n      valid: true,\n      receipt,\n      payerAddress,\n      paymentAmount,\n    }\n  } catch (error) {\n    console.error('Error verifying transaction:', error)\n    throw new Error('Failed to verify transaction')\n  }\n}\n\n/**\n * Helper to check if an address is valid\n */\nexport function isValidAddress(address: string): boolean {\n  return ethers.isAddress(address)\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;AAED;;AAEA,kDAAkD;AAClD,IAAI,WAAmC;AAEhC,SAAS;IACd,IAAI,CAAC,UAAU;QACb,MAAM,SAAS,QAAQ,GAAG,CAAC,aAAa;QACxC,IAAI,CAAC,QAAQ;YACX,MAAM,IAAI,MAAM;QAClB;QACA,WAAW,IAAI,gPAAM,CAAC,eAAe,CAAC;IACxC;IACA,OAAO;AACT;AAEA,oDAAoD;AACpD,MAAM,YAAY;IAChB;IACA;IACA;IACA;IACA;CACD;AAED,uBAAuB;AACvB,MAAM,uBAAuB;IAC3B;IACA;IACA;IACA;IACA;CACD;AAED,2CAA2C;AAC3C,MAAM,uBAAuB;IAC3B;CACD;AAKM,SAAS;IACd,MAAM,eAAe,QAAQ,GAAG,CAAC,iBAAiB;IAClD,IAAI,CAAC,cAAc;QACjB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,IAAI,gPAAM,CAAC,QAAQ,CAAC,cAAc,WAAW;AACtD;AAKO,SAAS;IACd,MAAM,kBAAkB,QAAQ,GAAG,CAAC,wBAAwB;IAC5D,IAAI,CAAC,iBAAiB;QACpB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,IAAI,gPAAM,CAAC,QAAQ,CAAC,iBAAiB,sBAAsB;AACpE;AAKO,SAAS;IACd,MAAM,kBAAkB,QAAQ,GAAG,CAAC,wBAAwB;IAC5D,IAAI,CAAC,iBAAiB;QACpB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,IAAI,gPAAM,CAAC,QAAQ,CAAC,iBAAiB,sBAAsB;AACpE;AAOO,eAAe,gBAAgB,WAAmB;IACvD,IAAI;QACF,MAAM,kBAAkB;QACxB,MAAM,gBAAgB,MAAM,gBAAgB,eAAe,CAAC;QAC5D,OAAO,OAAO,cAAc,QAAQ;IACtC,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM,IAAI,MAAM;IAClB;AACF;AAOO,eAAe,yBAAyB,MAAc;IAC3D,IAAI;QACF,MAAM,WAAW;QACjB,MAAM,UAAU,MAAM,SAAS,qBAAqB,CAAC;QAErD,IAAI,CAAC,SAAS;YACZ,OAAO;gBAAE,OAAO;gBAAO,OAAO;YAAwB;QACxD;QAEA,iCAAiC;QACjC,IAAI,QAAQ,MAAM,KAAK,GAAG;YACxB,OAAO;gBAAE,OAAO;gBAAO,OAAO;YAAqB;QACrD;QAEA,0DAA0D;QAC1D,MAAM,yBAAyB,QAAQ,GAAG,CAAC,wBAAwB,EAAE;QACrE,IAAI,QAAQ,EAAE,EAAE,kBAAkB,wBAAwB;YACxD,OAAO;gBAAE,OAAO;gBAAO,OAAO;YAA2C;QAC3E;QAEA,sCAAsC;QACtC,MAAM,kBAAkB;QACxB,IAAI,gBAAgB;QACpB,IAAI,eAAe;QAEnB,KAAK,MAAM,OAAO,QAAQ,IAAI,CAAE;YAC9B,IAAI;gBACF,MAAM,YAAY,gBAAgB,SAAS,CAAC,QAAQ,CAAC;oBACnD,QAAQ;2BAAI,IAAI,MAAM;qBAAC;oBACvB,MAAM,IAAI,IAAI;gBAChB;gBAEA,IAAI,WAAW,SAAS,eAAe;oBACrC,eAAe,UAAU,IAAI,CAAC,KAAK;oBACnC,gBAAgB,UAAU,IAAI,CAAC,MAAM,CAAC,QAAQ;oBAC9C;gBACF;YACF,EAAE,OAAO,GAAG;gBAEV;YACF;QACF;QAEA,OAAO;YACL,OAAO;YACP;YACA;YACA;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,MAAM,IAAI,MAAM;IAClB;AACF;AAKO,SAAS,eAAe,OAAe;IAC5C,OAAO,gPAAM,CAAC,SAAS,CAAC;AAC1B"}},
    {"offset": {"line": 457, "column": 0}, "map": {"version":3,"sources":["file:///Users/ethan/Desktop/chiliz-ja/app/api/payment/confirm/route.ts"],"sourcesContent":["/**\n * POST /api/payment/confirm\n * Verify and record a payment transaction\n */\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { z } from 'zod'\nimport { requireAuth } from '@/lib/auth'\nimport { prisma } from '@/lib/prisma'\nimport { verifyPaymentTransaction } from '@/lib/ethers'\n\nconst RequestSchema = z.object({\n  txHash: z.string().regex(/^0x[a-fA-F0-9]{64}$/, 'Invalid transaction hash'),\n})\n\nexport async function POST(request: NextRequest) {\n  try {\n    console.log('üîµ Payment confirmation request received')\n    \n    // Require authentication\n    const user = await requireAuth()\n    console.log('‚úÖ User authenticated:', user.address)\n\n    const body = await request.json()\n    console.log('üì¶ Request body:', body)\n    \n    const { txHash } = RequestSchema.parse(body)\n    console.log('‚úÖ txHash validated:', txHash)\n\n    // Check if payment already exists\n    const existingPayment = await prisma.payment.findUnique({\n      where: { txHash },\n    })\n\n    if (existingPayment) {\n      if (existingPayment.status === 'CONFIRMED') {\n        return NextResponse.json({\n          success: true,\n          status: 'CONFIRMED',\n          message: 'Payment already confirmed',\n        })\n      }\n      // If pending or failed, we'll re-verify\n    }\n\n    // Verify the transaction on-chain\n    const verification = await verifyPaymentTransaction(txHash)\n\n    if (!verification.valid) {\n      // Update or create payment record as FAILED\n      await prisma.payment.upsert({\n        where: { txHash },\n        update: {\n          status: 'FAILED',\n          updatedAt: new Date(),\n        },\n        create: {\n          userId: user.id,\n          txHash,\n          amount: '0',\n          status: 'FAILED',\n        },\n      })\n\n      return NextResponse.json(\n        { error: verification.error || 'Transaction verification failed' },\n        { status: 400 }\n      )\n    }\n\n    // Verify the payer matches the authenticated user\n    if (verification.payerAddress && verification.payerAddress.toLowerCase() !== user.address.toLowerCase()) {\n      return NextResponse.json(\n        { error: 'Transaction payer does not match authenticated user' },\n        { status: 403 }\n      )\n    }\n\n    // Create or update payment record as CONFIRMED\n    const payment = await prisma.payment.upsert({\n      where: { txHash },\n      update: {\n        status: 'CONFIRMED',\n        amount: verification.paymentAmount || '0',\n        updatedAt: new Date(),\n      },\n      create: {\n        userId: user.id,\n        txHash,\n        amount: verification.paymentAmount || '0',\n        status: 'CONFIRMED',\n      },\n    })\n\n    // ‚úÖ IMPORTANT: Set user as logged in after successful payment\n    await prisma.user.update({\n      where: { id: user.id },\n      data: { isLoggedIn: true },\n    })\n\n    console.log(`‚úÖ User ${user.address} is now logged in after payment`)\n\n    return NextResponse.json({\n      success: true,\n      status: 'CONFIRMED',\n      payment: {\n        id: payment.id,\n        txHash: payment.txHash,\n        amount: payment.amount,\n        createdAt: payment.createdAt,\n      },\n    })\n  } catch (error) {\n    console.error('‚ùå Payment confirmation error:', error)\n    \n    if (error instanceof Error && error.message.includes('Unauthorized')) {\n      console.error('‚ùå Auth error:', error.message)\n      return NextResponse.json(\n        { error: 'Unauthorized - Please connect your wallet' },\n        { status: 401 }\n      )\n    }\n\n    if (error instanceof z.ZodError) {\n      console.error('‚ùå Validation error:', error.errors)\n      return NextResponse.json(\n        { error: 'Invalid request data', details: error.errors },\n        { status: 400 }\n      )\n    }\n\n    console.error('‚ùå Unexpected error confirming payment:', error)\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":"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"}}]
}